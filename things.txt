Counting spanning trees - D
Linear programming - Q
	https://www.hackerearth.com/submission/20905850/
	https://codeforces.com/contest/375/submission/44891061
FFT, NTT - Q
	https://codeforces.com/contest/438/submission/39451171
	Poly Invert: R(2n) = 2R(n) - R(n) ^ 2 * F where R(z) = invert F(z)
	Poly Sqrt: 2 * S(2n) = S(n) + F * S(n) ^ -1

Partition formula - Q
#Generating functions
Gauss elimination - D
#Taylor expansion
Count prime numbers up to N - D

Dinic flow - Q
Mincost maxflow - Q
Bounded flow - D
Mincost max-matching - Hungarian algorithm - D
General matching - D
Mincut undirected graph - StoerWagner - D

Directed minimum spanning tree - D
Bridge & articulations - D
Stable marriage - D

Treap - Q
Big integer - D
#Splay
Link cut tree - D 
#Heavy light decomposition

System of linear equations - D
Extended Euclide - D
Euler phi - Q
Pollard Rho - Q

Suffix automata - Q
Suffix array - D - Done
Aho Corasick - D
Z-algorithm - D
KMP - D
Manacher - D

Convex Hull trick:
	stack based - D
	IT - D
Knuth optimization - D

Geometry:
	Point
	Line
	Circle
	Plane
	Convex hull
	Rect in Rect
